# Исследование зависимости времени исполнения ядра от различных параметров при перемножении матриц одинакового ранга

Этот проект является видоизменением оригинального проекта [myGEMM](https://github.com/CNugteren/myGEMM) 
с целью сбора экспериментальных данных

## Платформа

 - BananaPi на RISC-v архитектуре
 - Был использован проект myGEMM с малыми измененниями

## Инструкция по работе с проектом

### Общие требования

 - Наличие компилятора C++
 - Наличие make
 - Наличие OpenCL (можно проверить наличие с помощью ввода в консоль clinfo)
 - Наличие clBLAS

#### Установка компилятора C++

```bash
sudo apt install g++
```

#### Установка make

```bash
sudo apt install make
```

#### Установка OpenCL

 - К сожалению все зависит от вендора, но можно проверить наличие командой `clinfo`,
  если он не распознал или вывел 0 платформ, то приедется установить самые свежие драйвера и 
  поискать подходящий SDK от вендора

#### Установка clBLAS

```bash
sudo apt install libclblas-dev
```

### При наличии графического ускорителя c CUDA ядрами

 - Нужно становить cuBLAS
 - Нужно зайти в Makefile и поменять значение ENABLE_CUDA с 0 на 1, этот параметр показывает 
 испсользуется ли CUDA-специфичные функции и ядра

### Вывод программы

backend | kernel | work group size | opencl standart | matrix size |	work time(sec) |
| ------ |	------ |	------ |	------ |	------ |	------ |
| myGEMM.cl |	1 |	8 |	-cl-std=CL1.2 |	256 |	0.08002 |

### Инструкция по использованию

 - Если хочется просто запустить, то достаточно написать make
 - Если хочется провести иследования, то нужно работать с файлами:
    - research.py (с помощью него происходит автоматичекий запуск и перенаправление всего вывода в файл): 
    можно ислледовать вас интересующие ядра(kernels) и размеры рабочих групп(work_groups)
    - src/common.h: 
    можно ислледовать вас интересующие размеры матрицы, которые начинаются с MINSIZE и заканчиваются MAXSIZE 
    с шагом x2
    - src/settings.h (тут находятся параметры связанные с ядрами):
    можно исследовать различные ядра(KERNELS) и размеры рабочих групп(TS), но лучше не менять их руками, а 
    использовать research.py, еще есть параметры компиляции ядер(COMPILER_OPTIONS), в которые можно через 
    пробел указывать различные флаги, например быстрая математика, и параметры, например стандарт
    - filter.py (фильтрует данные из выходного файла программы, который больше выполняет функцию логирования):
    можно указывать файлы, который хотим отфильтровать(input_file) и в который хотим записать экспериментальные 
    данные(output_file)

## Результаты исследования

![image](https://github.com/user-attachments/assets/0159d49b-fbb8-418d-b5e6-67b12e3a491a)

 - Успел провести только по 50 измерений для первых 5 ядер и 3 разных размеров рабочих групп
 - В моем маленьком исследовании по графику моно судить, что в среднем лучшей конфигурацией было
 4 ядро с размером рабочей группы 32
